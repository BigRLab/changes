"""A model for storing information about how specific images should
be cached on slaves. This helps with always having the correct image
ahead of time as well as garbage collecting unneeded images on slaves.
"""

from __future__ import absolute_import

from sqlalchemy import Column, DateTime, ForeignKey
from sqlalchemy.orm import relationship

from changes.config import db
from changes.db.types.guid import GUID


class CachedSnapshotImage(db.Model):
    """
    A cached snapshot is a snapshot image that is tracked by a caching/garbage
    collection system. Not all snapshots are necessarily cached and
    slaves should not expect to have any snapshots that are not
    marked as a cached snapshot (thus they will have to download them
    on potentially every build).

    Cached snapshots are also garbage collected. And because we use
    null expiration dates to indicate unexpiring snapshots, we cannot
    overload the use of null to mean to not cache it. In this sense
    this table is necessary instead of just adding a column to the
    snapshot table.
    """

    __tablename__ = 'cached_snapshot_image'

    # snapshot ids are unique so we might as well make it our primary key.
    #
    # This is NOT autogenerated and is REQUIRED for creation.
    id = Column(GUID, ForeignKey('snapshot_image.id'), nullable=False, primary_key=True)

    # A slave is expected to have anything whose expiration date is
    # either null (not-yet-set) or past the current time.
    #
    # It is also safe to garbage collect this table itself. That is,
    # expired rows can be deleted. However, it is rather small
    # compared to additional cruft we gather so it is not necessarily
    # worth doing so.
    expiration_date = Column(DateTime, nullable=True)

    snapshot_image = relationship('SnapshotImage', innerjoin=True)

    def __init__(self, id, **kwargs):
        super(CachedSnapshotImage, self).__init__(id=id, **kwargs)
